fred %<>% rename(gdp = Value.x,
m2 = Value.y,
gov = Value)
head(fred)
fred %<>% filter(Date >= '1960-01-01') %>%
filter(Date <= '2019-12-31')
ggplot(fred, aes(x = Date, y = m2)) +
theme_bw() +
geom_line() +
xlab('Year') +
ylab('') +
ggtitle('Time series of M2 money supply, quarterly')
acf(fred$m2,
na.action = na.pass) # ignore any missing data/gaps in the time series
acf(fred$m2,
na.action = na.exclude, # Ignore any missing data
lag.max = 15, # Number of lags to include
plot = FALSE)
fred %<>% mutate(ygrowth = log(gdp)-lag(log(gdp)),
mgrowth = log(m2)-lag(log(m2)),
ggrowth = log(gov)-lag(log(gov)))
fred %<>% mutate(unit = 'same')
m <- 0.75*nrow(fred)^(1/3)
m
# Round up
m <- ceiling(m)
m
mod.c <- feols(ygrowth ~ mgrowth, fred,
panel.id = c('unit', 'Date'),
vcov = NW(5))
mod.d <- feols(ygrowth ~ ggrowth, fred,
panel.id = c('unit', 'Date'),
vcov = NW(5))
etable(mod.c, mod.d)
mod.e <- feols(ygrowth ~ l(mgrowth, 0:1), fred,
panel.id = c('unit', 'Date'),
vcov = NW(5))
mod.f <- feols(ygrowth ~ l(ggrowth, 0:1),
fred,panel.id = c('unit', 'Date'),
vcov = NW(5))
# Or combining them into one command
mods.ef <- feols(ygrowth ~ sw(l(mgrowth, 0:1),
l(ggrowth, 0:1)),
fred,panel.id = c('unit', 'Date'),
vcov = NW(5))
etable(mods.ef)
# Create first-differenced versions of our regressors
fred %<>% mutate(diff.mgrowth = mgrowth-lag(mgrowth),
diff.ggrowth = ggrowth-lag(ggrowth))
mod.g <- feols(ygrowth ~ l(diff.mgrowth, 0:3) + l(mgrowth, 4) + l(diff.ggrowth, 0:3) + l(ggrowth, 4),
fred, panel.id = c('unit', 'Date'),
vcov = NW(5))
etable(mod.g)
library(tidyverse)
library(magrittr)
library(haven)
library(fixest)
library(ggplot2)
library(Quandl) # To download FRED data
library(readxl)
Quandl.api_key('xHu2y3xExQ6bGkGqcYEi') # This is my personal API key
gdp <- Quandl('FRED/GDPC1')
m2 <- Quandl('FRED/M2REAL')
gov <- Quandl('FRED/GCEC1')
head(gdp)
head(m2)
head(gov)
fred <- left_join(gdp, m2, by = 'Date') %>%
left_join(gov, by = 'Date')
head(fred)
fred %<>% rename(gdp = Value.x,
m2 = Value.y,
gov = Value)
head(fred)
fred %<>% filter(Date >= '1960-01-01') %>%
filter(Date <= '2019-12-31')
ggplot(fred, aes(x = Date, y = m2)) +
theme_bw() +
geom_line() +
xlab('Year') +
ylab('') +
ggtitle('Time series of M2 money supply, quarterly')
acf(fred$m2,
na.action = na.pass) # ignore any missing data/gaps in the time series
acf(fred$m2,
na.action = na.exclude, # Ignore any missing data
lag.max = 15, # Number of lags to include
plot = FALSE)
fred %<>% mutate(ygrowth = log(gdp)-lag(log(gdp)),
mgrowth = log(m2)-lag(log(m2)),
ggrowth = log(gov)-lag(log(gov)))
fred %<>% mutate(unit = 'same')
m <- 0.75*nrow(fred)^(1/3)
m
# Round up
m <- ceiling(m)
m
mod.c <- feols(ygrowth ~ mgrowth, fred,
panel.id = c('unit', 'Date'),
vcov = NW(5))
mod.d <- feols(ygrowth ~ ggrowth, fred,
panel.id = c('unit', 'Date'),
vcov = NW(5))
etable(mod.c, mod.d)
mod.e <- feols(ygrowth ~ l(mgrowth, 0:1), fred,
panel.id = c('unit', 'Date'),
vcov = NW(5))
mod.f <- feols(ygrowth ~ l(ggrowth, 0:1),
fred,panel.id = c('unit', 'Date'),
vcov = NW(5))
# Or combining them into one command
mods.ef <- feols(ygrowth ~ sw(l(mgrowth, 0:1),
l(ggrowth, 0:1)),
fred,panel.id = c('unit', 'Date'),
vcov = NW(5))
etable(mods.ef)
# Create first-differenced versions of our regressors
fred %<>% mutate(diff.mgrowth = mgrowth-lag(mgrowth),
diff.ggrowth = ggrowth-lag(ggrowth))
mod.g <- feols(ygrowth ~ l(diff.mgrowth, 0:3) + l(mgrowth, 4) + l(diff.ggrowth, 0:3) + l(ggrowth, 4),
fred, panel.id = c('unit', 'Date'),
vcov = NW(5))
etable(mod.g)
stl.est <- coeftable(mod.g)
stl.est
# Collect the cumulative multipliers
cumu <- data.frame(Estimate = stl.est[-1,'Estimate']) %>%
mutate(Lag = rep(0:4, 2),
Policy = rep(c('Monetary', 'Fiscal'), each = 5))
dyna <- group_by(cumu, Policy) %>%
mutate(Estimate = ifelse(Lag == 0, Estimate, Estimate-lag(Estimate)))
multipliers <- rbind(cumu, dyna) %>%
mutate(Multiplier = rep(c('Cumulative', 'Dynamic'), each = 10))
multipliers
cumu
dyna
multi.table <- left_join(cumu, dyna)
multi.table
multi.table <- full_join(cumu, dyna)
multi.table
multipliers <- rbind(cumu, dyna) %>%
mutate(Multiplier = rep(c('Cumulative', 'Dynamic'), each = 10))
multipliers <- rbind(cumu, dyna) %>%
mutate(Multiplier = rep(c('Cumulative', 'Dynamic'), each = 10))
multipliers <- rbind(cumu, dyna) %>%
mutate(Multiplier = rep(c('Cumulative', 'Dynamic'), each = 10))
multipliers <- rbind(cumu, dyna) %>%
mutate(Multiplier = rep(c('Cumulative', 'Dynamic'), each = 10))
multipliers
multi.table <- pivot_wider(multipliers, id.cols = c('Lag'))
multi.table <- pivot_wider(multipliers, id.cols = Lag)
?pivot_wider
multi.table <- pivot_wider(multipliers,
id.cols = Lag,
values_from = Estimate)
head(multipliers)
multi.table <- pivot_wider(multipliers,
id.cols = 'Lag',
values_from = 'Estimate')
multi.table <- pivot_wider(multipliers,
id.cols = Lag,
values_from = Estimate,
names_from = Multiplier)
multi.table <- pivot_wider(multipliers,
id.cols = 'Lag',
values_from = 'Estimate',
names_from = 'Multiplier')
multi.table <- pivot_wider(multipliers,
id.cols = 'Lag',
values_from = 'Estimate',
names_from = c('Multiplier', 'Policy'))
multipliers <- rbind(cumu, dyna) %>%
mutate(Multiplier = rep(c('Cumulative', 'Dynamic'), each = 10))
multipliers
multi.table <- pivot_wider(multipliers,
id.cols = Lag,
values_from = Estimate,
names_from = paste(Policy, Multiplier))
multi.table <- pivot_wider(multipliers,
id.cols = 'Lag',
values_from = 'Estimate',
names_from = paste(c('Policy', 'Multiplier')))
names(multipliers)
multi.table <- pivot_wider(multipliers,
names_from = c(Policy, Multiplier),
values_from = Estimate)
multi.table
print(multi.table)
library(ggplot2)
library(gridExtra)
plot.dyn <- coefplot(oil.dyn, drop = 'Constant',
main = 'The effect of oil prices on IP growth rate\nDynamic multipliers',
xlab = 'Lag',
ci.join = T, ci.lty = 0, ci.fill = T, ci.fill.par = list(col = 'lightblue'),
pt.join = T)
plot.cumdyn <- coefplot(oil.cumdyn, drop = 'Constant', ci.join = T,
main = 'The effect of oil prices on IP growth rate\nCumulative dynamic multipliers',
xlab = 'Lag',
ci.lty = 0, ci.fill = T, ci.fill.par = list(col = 'red'),
pt.join = T)
plot.dyn <- coefplot(oil.dyn, drop = 'Constant',
main = 'The effect of oil prices on IP growth rate\nDynamic multipliers',
xlab = 'Lag',
ci.join = T, ci.lty = 0, ci.fill = T, ci.fill.par = list(col = 'lightblue'),
pt.join = T)
library(tidyverse)
library(magrittr)
library(haven)
library(fixest)
library(ggplot2)
library(Quandl) # To download FRED data
library(readxl)
library(gridExtra)
Quandl.api_key('xHu2y3xExQ6bGkGqcYEi') # This is my personal API key
gdp <- Quandl('FRED/GDPC1')
m2 <- Quandl('FRED/M2REAL')
gov <- Quandl('FRED/GCEC1')
head(gdp)
head(m2)
head(gov)
fred <- left_join(gdp, m2, by = 'Date') %>%
left_join(gov, by = 'Date')
head(fred)
fred %<>% rename(gdp = Value.x,
m2 = Value.y,
gov = Value)
head(fred)
fred %<>% filter(Date >= '1960-01-01') %>%
filter(Date <= '2019-12-31')
ggplot(fred, aes(x = Date, y = m2)) +
theme_bw() +
geom_line() +
xlab('Year') +
ylab('') +
ggtitle('Time series of M2 money supply, quarterly')
acf(fred$m2,
na.action = na.pass) # ignore any missing data/gaps in the time series
acf(fred$m2,
na.action = na.exclude, # Ignore any missing data
lag.max = 15, # Number of lags to include
plot = FALSE)
fred %<>% mutate(ygrowth = log(gdp)-lag(log(gdp)),
mgrowth = log(m2)-lag(log(m2)),
ggrowth = log(gov)-lag(log(gov)))
fred %<>% mutate(unit = 'same')
m <- 0.75*nrow(fred)^(1/3)
m
# Round up
m <- ceiling(m)
m
mod.c <- feols(ygrowth ~ mgrowth, fred,
panel.id = c('unit', 'Date'),
vcov = NW(5))
mod.d <- feols(ygrowth ~ ggrowth, fred,
panel.id = c('unit', 'Date'),
vcov = NW(5))
etable(mod.c, mod.d)
mod.e <- feols(ygrowth ~ l(mgrowth, 0:1), fred,
panel.id = c('unit', 'Date'),
vcov = NW(5))
mod.f <- feols(ygrowth ~ l(ggrowth, 0:1),
fred,panel.id = c('unit', 'Date'),
vcov = NW(5))
# Or combining them into one command
mods.ef <- feols(ygrowth ~ sw(l(mgrowth, 0:1),
l(ggrowth, 0:1)),
fred,panel.id = c('unit', 'Date'),
vcov = NW(5))
etable(mods.ef)
# Create first-differenced versions of our regressors
fred %<>% mutate(diff.mgrowth = mgrowth-lag(mgrowth),
diff.ggrowth = ggrowth-lag(ggrowth))
mod.g <- feols(ygrowth ~ l(diff.mgrowth, 0:3) + l(mgrowth, 4) + l(diff.ggrowth, 0:3) + l(ggrowth, 4),
fred, panel.id = c('unit', 'Date'),
vcov = NW(5))
etable(mod.g)
stl.est <- coeftable(mod.g)
stl.est
# Collect the cumulative multipliers
cumu <- data.frame(Estimate = stl.est[-1,'Estimate']) %>%
mutate(Lag = rep(0:4, 2),
Policy = rep(c('Monetary', 'Fiscal'), each = 5))
dyna <- group_by(cumu, Policy) %>%
mutate(Estimate = ifelse(Lag == 0, Estimate, Estimate-lag(Estimate)))
multipliers <- rbind(cumu, dyna) %>%
mutate(Multiplier = rep(c('Cumulative', 'Dynamic'), each = 10))
multi.table <- pivot_wider(multipliers,
names_from = c(Policy, Multiplier),
values_from = Estimate)
print(multi.table)
ggplot(multipliers, aes(x = Lag, y = Estimate, color = Multiplier)) +
theme_bw() +
geom_line() +
theme(legend.position = 'top') +
ggtitle('Estimated multipliers') +
xlab('Lags') + ylab('') + facet_grid(~ Policy)
macro <- read_excel('data/UsMacro_Monthly.xlsx')
head(macro)
macro %<>% mutate(ip.growth = 100*(log(IP)-log(lag(IP))))
macro.sample <- filter(macro, Year >= 1960 & Year <= 2017)
mean(macro.sample$ip.growth)
sd(macro.sample$ip.growth)
macro %<>% mutate(Date = as.Date(ISOdate(Year, Month, 1)))
ggplot(macro, aes(x = Date, y = Oil)) +
theme_bw() + # A black-and-white theme I like over the gray default
geom_line() + # Draw a line graph using Date on the x and Oil on the y
xlab('Date') + ggtitle('Time series of O') + ylab('')
m <-  0.75*nrow(macro)^(1/3)
m <- ceiling(m)
m
# Create an id variable like before
macro %<>% mutate(id = 999)
oil.dyn <- feols(ip.growth ~ l(Oil, 0:18), macro,
panel.id = ~ id + Date,
vcov = NW(m))
etable(oil.dyn, fitstat = ~ wald + wald.p)
wald(oil.dyn)
macro %<>% mutate(diff.Oil = Oil-lag(Oil))
oil.cumdyn <- feols(ip.growth ~ l(diff.Oil, 0:17) + l(Oil, 18),
macro,
panel.id = ~ id + Date,
vcov = NW(m))
etable(oil.dyn, oil.cumdyn)
coefplot(oil.dyn, drop = 'Constant',
main = 'Dynamic multipliers', xlab = 'Lag')
coefplot(oil.cumdyn, drop = c('Constant', 'lag(Oil, 18)'),
main = 'Cumulative multipliers', xlab = 'Lag')
plot.dyn <- coefplot(oil.dyn, drop = 'Constant',
main = 'The effect of oil prices on IP growth rate\nDynamic multipliers',
xlab = 'Lag',
ci.join = T, ci.lty = 0, ci.fill = T, ci.fill.par = list(col = 'lightblue'),
pt.join = T)
plot.cumdyn <- coefplot(oil.cumdyn, drop = 'Constant', ci.join = T,
main = 'The effect of oil prices on IP growth rate\nCumulative dynamic multipliers',
xlab = 'Lag',
ci.lty = 0, ci.fill = T, ci.fill.par = list(col = 'red'),
pt.join = T)
grid.arrange(plot.dyn, plot.cumdyn)
Quandl.api_key('xHu2y3xExQ6bGkGqcYEi') # This is my personal API key
library(tidyverse)
library(magrittr)
library(haven)
library(fixest)
library(ggplot2)
library(Quandl) # To download FRED data
library(readxl)
Quandl.api_key('xHu2y3xExQ6bGkGqcYEi') # This is my personal API key
gdp <- Quandl('FRED/GDPC1')
m2 <- Quandl('FRED/M2REAL')
gov <- Quandl('FRED/GCEC1')
head(gdp)
head(m2)
head(gov)
fred <- left_join(gdp, m2, by = 'Date') %>%
left_join(gov, by = 'Date')
head(fred)
fred %<>% filter(Date >= '1960-01-01' & Date <= '2019-12-31')
summarize(fred$Date)
fred %<>% filter(Date >= '1960-01-01' & Date <= '2019-12-31')
summary(fred$Date)
fred %<>% rename(gdp = Value.x,
m2 = Value.y,
gov = Value)
ggplot(fred, aes(x = Date, y = m2)) +
geom_line()
fred %<>% rename(gdp = Value.x,
m2 = Value.y,
gov = Value)
ggplot(fred, aes(x = Date, y = m2)) +
theme_bw() +
geom_line()
ggplot(fred, aes(x = Date, y = m2)) +
theme_bw() +
geom_line() + xlab('Year') + ylab('') + ggtitle('Time series of M2 money supply, quarterly')
acf(fred$m2, na.action = na.pass)
acf(fred$m2, na.action = na.pass, plot = FALSE)
acf(fred$m2, na.action = na.pass, plot = FALSE, lag.max = 5)
fred %<>% mutate(ygrowth = log(gdp)-lag(log(gdp)),
mgrowth = log(m2)-lag(log(m2)),
ggrowth = log(gov)-lag(log(gov)))
fred %<>% mutate(ygrowth = log(gdp)-lag(log(gdp)),
mgrowth = log(m2)-lag(log(m2)),
ggrowth = log(gov)-lag(log(gov)))
head(fred)
fred %<>% mutate(unit = 'same')
m <- 0.75*nrow(fred)^(1/3)
m
m <- 0.75*nrow(fred)^(1/3)
m
m <- ceiling(m)
m
mod.c <- feols(ygrowth ~ mgrowth, fred,
panel.id = c('unit', 'Date'),
vcov = NW(m))
mod.d <- feols(ygrowth ~ ggrowth, fred,
panel.id = c('unit', 'Date'),
vcov = NW(m))
etable(mod.c, mod.d)
mod.e <- feols(ygrowth ~ mgrowth + l(mgrowth), fred,
panel.id = c('unit', 'Date'),
vcov = NW(m))
mod.f <- feols(ygrowth ~ ggrowth + l(ggrowth), fred,
panel.id = c('unit', 'Date'),
vcov = NW(m))
mods.ef <- feols(ygrowth ~ sw(l(mgrowth, 0:1),
l(ggrowth, 0:1)), fred,
panel.id = c('unit', 'Date'),
vcov = NW(m))
etable(mods.ef)
mod.e <- feols(ygrowth ~ mgrowth + l(mgrowth), fred,
panel.id = c('unit', 'Date'),
vcov = NW(m))
mod.f <- feols(ygrowth ~ ggrowth + l(ggrowth), fred,
panel.id = c('unit', 'Date'),
vcov = NW(m))
mods.ef <- feols(ygrowth ~ sw(l(mgrowth, 0:1),
l(ggrowth, 0:1)), fred,
panel.id = c('unit', 'Date'),
vcov = NW(m))
etable(mod.c, mod.d, mods.ef)
mod.e <- feols(ygrowth ~ mgrowth + l(mgrowth), fred,
panel.id = c('unit', 'Date'),
vcov = NW(m))
mod.f <- feols(ygrowth ~ ggrowth + l(ggrowth), fred,
panel.id = c('unit', 'Date'),
vcov = NW(m))
mods.ef <- feols(ygrowth ~ sw(l(mgrowth, 0:1),
l(ggrowth, 0:1)), fred,
panel.id = c('unit', 'Date'),
vcov = NW(m))
etable(mods.ef)
# Create first-differenced versions of our regressors
fred %<>% mutate(diff.mgrowth = mgrowth-lag(mgrowth),
diff.ggrowth = ggrowth=lag(ggrowth))
# Create first-differenced versions of our regressors
fred %<>% mutate(diff.mgrowth = mgrowth-lag(mgrowth),
diff.ggrowth = ggrowth-lag(ggrowth))
mod.g <- feols(ygrowth ~ l(diff.mgrowth, 0:3) + l(mgrowth, 4) +
l(diff.ggrowth, 0:3) + l(ggrowth),
fred, panel.id = c('unit', 'Date'),
vcov = NW(m))
etable(mod.g)
# Create first-differenced versions of our regressors
fred %<>% mutate(diff.mgrowth = mgrowth-lag(mgrowth),
diff.ggrowth = ggrowth-lag(ggrowth))
mod.g <- feols(ygrowth ~ l(diff.mgrowth, 0:3) + l(mgrowth, 4) +
l(diff.ggrowth, 0:3) + l(ggrowth, 4),
fred, panel.id = c('unit', 'Date'),
vcov = NW(m))
etable(mod.g)
stl.est <- coeftable(mod.g)
stl.est
# Collect the cumulative multipliers
cumu <- data.frame(Estimate = stl.est[-1,'Estimate']) %>%
mutate(Lag = rep(0:4, 2),
Policy = rep(c('Monetary', 'Fiscal'), each = 5))
dyna <- group_by(cumu, Policy) %>%
mutate(Estimate = ifelse(Lag == 0, Estimate, Estimate-lag(Estimate)))
multipliers <- rbind(cumu, dyna) %>%
mutate(Multiplier = rep(c('Cumulative', 'Dynamic'), each = 10))
multi.table <- pivot_wider(multipliers,
names_from = c(Policy, Multiplier),
values_from = Estimate)
print(multi.table)
ggplot(multipliers, aes(x = Lag, y = Estimate, color = Multiplier)) +
theme_bw() +
geom_line() +
theme(legend.position = 'top') +
ggtitle('Estimated multipliers') +
xlab('Lags') + ylab('') + facet_grid(~ Policy)
macro <- read_excel('data/UsMacro_Monthly.xlsx')
head(macro)
macro %<>% mutate(ip.growth = 100*(log(IP)-log(lag(IP))))
macro.sample <- filter(macro, Year >= 1960 & Year <= 2017)
mean(macro.sample$ip.growth)
sd(macro.sample$ip.growth)
macro %<>% mutate(Date = as.Date(ISOdate(Year, Month, 1)))
ggplot(macro, aes(x = Date, y = Oil)) +
theme_bw() + # A black-and-white theme I like over the gray default
geom_line() + # Draw a line graph using Date on the x and Oil on the y
xlab('Date') + ggtitle('Time series of O') + ylab('')
m <-  0.75*nrow(macro)^(1/3)
m <- ceiling(m)
m
# Create an id variable like before
macro %<>% mutate(id = 999)
oil.dyn <- feols(ip.growth ~ l(Oil, 0:18), macro,
panel.id = ~ id + Date,
vcov = NW(m))
etable(oil.dyn)
etable(oil.dyn, fitstat + ~ wald + wald.p)
etable(oil.dyn, fitstat = ~ wald + wald.p)
wald(oil.dyn)
macro %<>% mutate(diff.Oil = Oil-lag(Oil))
oil.cumdyn <- feols(ip.growth ~ l(diff.Oil, 0:17) + l(Oil, 18),
macro,
panel.id = ~ id + Date,
vcov = NW(m))
etable(oil.dyn, oil.cumdyn)
coefplot(oil.dyn, drop = 'Constant')
coefplot(oil.dyn, drop = 'Constant')
coefplot(oil.cumdyn, drop = 'Constant')
dyn <- coefplot(oil.dyn, drop = 'Constant',
main = 'The effect of oil prices on IP growth rate\nDynamic multipliers',
xlab = 'Lag',
ci.join = T, ci.lty = 0, ci.fill = T, ci.fill.par = list(col = 'lightblue'),
pt.join = T)
cumdyn <- coefplot(oil.cumdyn, drop = 'Constant', ci.join = T,
main = 'The effect of oil prices on IP growth rate\nCumulative dynamic multipliers',
xlab = 'Lag',
ci.lty = 0, ci.fill = T, ci.fill.par = list(col = 'red'),
pt.join = T)
